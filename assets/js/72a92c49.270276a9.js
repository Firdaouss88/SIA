"use strict";(self.webpackChunksia_doc=self.webpackChunksia_doc||[]).push([[4162],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),p=u(n),m=a,g=p["".concat(l,".").concat(m)]||p[m]||c[m]||s;return n?i.createElement(g,o(o({ref:t},d),{},{components:n})):i.createElement(g,o({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,o[1]=r;for(var u=2;u<s;u++)o[u]=n[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},76e3:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return r},metadata:function(){return u},toc:function(){return c}});var i=n(87462),a=n(63366),s=(n(67294),n(3905)),o=["components"],r={hide_title:!0},l=void 0,u={unversionedId:"Formation PBI/801300/Format_Dax_Optimistation-DAX",id:"Formation PBI/801300/Format_Dax_Optimistation-DAX",title:"Format_Dax_Optimistation-DAX",description:"Moteur de stockage Vertipaq",source:"@site/docs/80-Formation PBI/801300/801300_Format_Dax_Optimistation-DAX.md",sourceDirName:"80-Formation PBI/801300",slug:"/Formation PBI/801300/Format_Dax_Optimistation-DAX",permalink:"/docs/Formation PBI/801300/Format_Dax_Optimistation-DAX",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/80-Formation PBI/801300/801300_Format_Dax_Optimistation-DAX.md",tags:[],version:"current",sidebarPosition:801300,frontMatter:{hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Format_Dax_Formation-Langage-DAX",permalink:"/docs/Formation PBI/801300/Format_Dax_Formation-Langage-DAX"},next:{title:"Hyperlien Formation Power  BI",permalink:"/docs/Formation PBI/HyperlienFormation-id"}},d={},c=[{value:"Moteur de stockage Vertipaq",id:"moteur-de-stockage-vertipaq",level:2},{value:"Base de donn\xe9es en colonnes VertiPaq en m\xe9moire",id:"base-de-donn\xe9es-en-colonnes-vertipaq-en-m\xe9moire",level:3},{value:"C&#39;est quoi Vertipaq?",id:"cest-quoi-vertipaq",level:3},{value:"Run Length Encoding (RLE)",id:"run-length-encoding-rle",level:3},{value:"Compression VertiPaq",id:"compression-vertipaq",level:3},{value:"Segmentation",id:"segmentation",level:3},{value:"Utilisation de la m\xe9moire de donn\xe9es",id:"utilisation-de-la-m\xe9moire-de-donn\xe9es",level:3},{value:"Mat\xe9rialisation dans DAX",id:"mat\xe9rialisation-dans-dax",level:3},{value:"Stockage interne",id:"stockage-interne",level:3},{value:"Les relations",id:"les-relations",level:3},{value:"Optimisation de grands mod\xe8les",id:"optimisation-de-grands-mod\xe8les",level:2},{value:"SUM ou SUMX ?",id:"sum-ou-sumx-",level:3},{value:"Optimisation des dimensions d\xe9g\xe9n\xe9r\xe9es",id:"optimisation-des-dimensions-d\xe9g\xe9n\xe9r\xe9es",level:3},{value:"Dimension bottlenecks",id:"dimension-bottlenecks",level:3}],p={toc:c};function m(e){var t=e.components,r=(0,a.Z)(e,o);return(0,s.kt)("wrapper",(0,i.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"optimistation-de-dax"},"Optimistation De DAX"),(0,s.kt)("h2",{id:"moteur-de-stockage-vertipaq"},"Moteur de stockage Vertipaq"),(0,s.kt)("p",null,"Afin d'optimiser DAX, il faudra tout d'abord savoir comment le moteur interne fonctionne.\nLe document va contenir les techniques de compression de Vertipaq, son processus de segmentation et comment optimiser l'utilisation de la m\xe9moire d'une base de donn\xe9es et comment utiliser l'analyseur Vertipaq pour recueillir des informations pr\xe9cises sur votre mod\xe8le ."),(0,s.kt)("h3",{id:"base-de-donn\xe9es-en-colonnes-vertipaq-en-m\xe9moire"},"Base de donn\xe9es en colonnes VertiPaq en m\xe9moire"),(0,s.kt)("p",null,"\xc0 chaque fois que le moteur SSAS (Sql server Analysis Services) re\xe7oit une requ\xeate DAX , la requ\xeate atteint Analysis Services et s'ex\xe9cute via le moteur de calcul DAX.\n\xc0 ce stade, il existe deux options pour r\xe9pondre \xe0 la requ\xeate : soit le moteur Vertipaq(xmSQL) doit r\xe9cup\xe9rer les donn\xe9es ou bien elles seront d\xe9j\xe0 stock\xe9es dans le moteur Vertipaq(Cached Data) , soit il utilise la technologie DIRECTQUERY(SQL) afin d'obtenir les donn\xe9es source."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_1",src:n(53378).Z,width:"1049",height:"500"})),(0,s.kt)("p",null,"Le traitement d'une' requ\xeate peut se faire soit en mode m\xe9moire (moteur Vertipaq) soit en mode DirectQuery, ce dernier va ex\xe9cuter la requ\xeate sur votre code SQL de base de donn\xe9es serveur."),(0,s.kt)("h3",{id:"cest-quoi-vertipaq"},"C'est quoi Vertipaq?"),(0,s.kt)("p",null,"Vertipaq est une base de donn\xe9es en colonnes en m\xe9moire, cela signifie fondamentalement que toutes les donn\xe9es doivent \xeatre stocker en m\xe9moire(RAM), et la mani\xe8re de les stocker est en colonnes non ligne par ligne ."),(0,s.kt)("p",null,"Il existe deux mani\xe8res de stocker les donn\xe9es , soit en colonnes soit en lignes:"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Stockage en ligne : "),"vous avez l'acc\xe8s rapide juste \xe0 une ligne par ligne de donn\xe9es peu importe combien de colonnes existent , alors vous d\xe9pensez plus de temps pendant l'entr\xe9e / sortie pour un processeur."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_2",src:n(79151).Z,width:"986",height:"452"})),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Stockage en colonne :")," vous avez acc\xe8s rapide \xe0 une seule colonne \xe0 la fois et \xe7a aide \xe0 r\xe9duite les entr\xe9es/ sorties \xe0 un magasin de donn\xe9es."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_3",src:n(80300).Z,width:"989",height:"486"})),(0,s.kt)("p",null,"Imaginons que , il y'a une limite physique, que vous ne pouvez pas augmenter de CPU ou avoir multiple processeur , vous \xeates obliger de suivre la m\xe9thode de stockage en colonnes car c'est la plus optimale c\xf4t\xe9 entr\xe9e/sortie dans un magasin de donn\xe9es."),(0,s.kt)("h3",{id:"run-length-encoding-rle"},"Run Length Encoding (RLE)"),(0,s.kt)("p",null,"Prenant l'exemple d'une colonne Trimestre qui vient d'une table de fait et qui sera utiliser dans diff\xe9rentes relations.\nLe fait RLE va d\xe9tecter o\xf9 la colonne va changer de Q1 au Q2 et il va stocker les informations en compacte non en r\xe9p\xe9tant la valeur.\nSi on a le cas de la colonne PRIX la valeur change si souvent \xe0 cause des remises , et d'autres calcul ,du coup RLE stocke la colonne original ."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_4",src:n(99863).Z,width:"786",height:"399"})),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"RLE")," travaille toujours colonne par colonne de base , et ce n'est pas le seul type d'encodage tabulaire existant , il existe aussi ",(0,s.kt)("strong",{parentName:"p"},"Dictionary encoding")," qui travaille par une autre m\xe9thode que RLE, il lit tous les valeurs distinctes et construit un dictionnaire qui contient 0,1,2,3,4... et ensuite il remplace la colonne originale par une nouvelle colonne qui contient les entr\xe9es du dictionnaire :"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_5",src:n(13959).Z,width:"840",height:"522"})),(0,s.kt)("h3",{id:"compression-vertipaq"},"Compression VertiPaq"),(0,s.kt)("p",null,"La compression dans Vertipaq provient du fait que vous stockez des donn\xe9es dans un magasin de colonnes \xe0 partir du dictionnaire encodage et de RLE."),(0,s.kt)("p",null,"Il est si important de parler de compression de donn\xe9es quand on explique le moteur Vertipaq parce que c'est une base de donn\xe9es en m\xe9moire et qui dit m\xe9moire dit optimisation et compression des entr\xe9es/sorties pour balayer toutes vos donn\xe9es.  "),(0,s.kt)("p",null,"Lorsque les donn\xe9es sont en m\xe9moire, le temps qui prend pour acc\xe9der \xe0 une information dans un registre CPU est de 1 ns, si on la cherche en cache premier niveau est de 4 ns ainsi de suite ."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_6",src:n(55800).Z,width:"633",height:"407"})),(0,s.kt)("h3",{id:"segmentation"},"Segmentation"),(0,s.kt)("p",null,"Une table de grande taille qui contient 10 milliards de lignes, il faudra beaucoup de temps pour la balayer ainsi beaucoup de stockage dans la RAM qui va la rendre trop lente en temps de r\xe9ponse , du coup l'outil Tabular d'Analysis Services va la diviser en segments.\nChaque segment contient des milliers de lignes comme en SSAS est de 8 millions de lignes, en Power BI un segment peut aller jusqu'\xe0 1 million.\nTabular lit segment par segment de vos donn\xe9es et pour chaque segment il effectue l'encodage dictionnaire et RLE."),(0,s.kt)("h3",{id:"utilisation-de-la-m\xe9moire-de-donn\xe9es"},"Utilisation de la m\xe9moire de donn\xe9es"),(0,s.kt)("p",null,"L'utilisation de la m\xe9moire de donn\xe9es d\xe9pend du nombre de colonnes et de la cardinalit\xe9 de chaque colonne, plus la cardinalit\xe9 est grande plus la performance est faible. Donc la cardinalit\xe9 est le seul point o\xf9 vous devez plus concentr\xe9 pour optimiser votre mod\xe8le."),(0,s.kt)("p",null,"Au moment de ex\xe9cution d'une requ\xeate vous aurez surement besoin de la m\xe9moire, et la quantit\xe9 de m\xe9moire d\xe9pend de la mat\xe9rialisation.\n",(0,s.kt)("em",{parentName:"p"},"C'est quoi la mat\xe9rialisation ?")," la mat\xe9rialisation est l'\xe9tape de la reconstruction de la structure de vos donn\xe9es, c'est comme le cas o\xf9 vous reconstruit votre base de donn\xe9es d'une base plate au base par stockage en colonnes."),(0,s.kt)("p",null,"il existe deux m\xe9thodes de mat\xe9rialisation :\n*. ",(0,s.kt)("strong",{parentName:"p"},"Early materialization(Mat\xe9rialisation pr\xe9coce)")," c'est une m\xe9thode fondamentale qui se fait par la reconstruction de votre originale structure \xe0 une structure plus facile \xe0 balayer ou \xe0 interroger ."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_7",src:n(88869).Z,width:"846",height:"561"})),(0,s.kt)("p",null,"\u200b\t*. ",(0,s.kt)("strong",{parentName:"p"},"Late materialization(Mat\xe9rialisation tardive)")," c'est une m\xe9thode qui utilise le BITMAP ou plut\xf4t l'indexation BITMAP (Un index bitmap est un type sp\xe9cial d'index de base de donn\xe9es qui utilise des bitmaps. ), donc il reconstruit pas ta structure originale, mais il index tes Ids pour faciliter le balayage des donn\xe9es."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_8",src:n(69023).Z,width:"864",height:"571"})),(0,s.kt)("h3",{id:"mat\xe9rialisation-dans-dax"},"Mat\xe9rialisation dans DAX"),(0,s.kt)("p",null,"Afin de comprendre ce qu'est la mat\xe9rialisation, regardez cette requ\xeate simple :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-DAX"},'\xc9VALUER\nLIGNE (\n    "R\xe9sultat", COUNTROWS ( R\xc9SUM\xc9 ( Ventes, Ventes[ProductKey] ) )\n)\n')),(0,s.kt)("p",null,"Le r\xe9sultat est le nombre distinct de cl\xe9s de produit dans la table ventes. vous pouvez imaginer comment VertiPaq peut ex\xe9cuter cette requ\xeate.\n\xc9tant donn\xe9 que la seule colonne interrog\xe9e est ",(0,s.kt)("em",{parentName:"p"},"ProductKey")," , il ne peut analyser que cette colonne, en trouvant toutes les valeurs dans la structure compress\xe9e de la colonne.\nLors de la num\xe9risation, il garde une trace des valeurs trouv\xe9es dans un index bitmap et, \xe0 la fin, il n'a qu'\xe0 compter les bits d\xe9finis.\nGr\xe2ce au parall\xe9lisme au niveau des segments, cette requ\xeate peut s'ex\xe9cuter rapidement sur de tr\xe8s grandes tables et la seule m\xe9moire qu'elle doit allouer est l'index bitmap pour compter les cl\xe9s."),(0,s.kt)("h3",{id:"stockage-interne"},"Stockage interne"),(0,s.kt)("p",null,"Afin d'optimiser un mod\xe8le ou une colonne il faudra d'abord savoir sa taille ,et cette information vous pouvez l'avoir de diff\xe9rentes mani\xe8res."),(0,s.kt)("p",null,"Il existe DMV (donn\xe9es vues de gestion) qui est un type de requ\xeate que vous ex\xe9cutez pour recueillir des informations sur le contenu de votre mod\xe8le de donn\xe9es ."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_9",src:n(25030).Z,width:"803",height:"501"})),(0,s.kt)("p",null,"Afin d'ex\xe9cuter des requ\xeates DMV, il faudra utiliser l'outil Vertipaq Analyzer qui se trouve sur le lien dans l'image ci-dessous, c'est un fichier Excel contenant des donn\xe9es Power Pivot mod\xe8le et qui utilise DMV pour se connecter \xe0 une instance SSAS, rassemble les informations tr\xe8s d\xe9taill\xe9es sur votre mod\xe8le de donn\xe9es ."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_10",src:n(79335).Z,width:"972",height:"341"})),(0,s.kt)("h3",{id:"les-relations"},"Les relations"),(0,s.kt)("p",null,"Comment le moteur traduit la relation entre Produit et table Ventes ?"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-DAX"},'CALCULATE (MIN (Sales [Date] ), Product [Color] = "Red" )\n')),(0,s.kt)("p",null,"Tout d'abord il scanne  la dimension Produit, apr\xe8s il num\xe9rise les lignes qui contiennent la condition pour filtrer la relation entre Produit et Ventes, et \xe0 la fin obtenir la date Min de cl\xe9 de produit dans la table des ventes."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_11",src:n(81421).Z,width:"882",height:"578"})),(0,s.kt)("h2",{id:"optimisation-de-grands-mod\xe8les"},"Optimisation de grands mod\xe8les"),(0,s.kt)("p",null,"Avec de petits mod\xe8les, le seul effort d'optimisation de votre code consiste \xe0 travailler au niveau DAX. Lorsque le mod\xe8le devient plus grand, la consommation de m\xe9moire devient d'une importance primordiale et vous devez non seulement apprendre \xe0 mesurer les performances de DAX et \xe0 tirer le meilleur parti du moteur de stockage - vous devez \xe9galement apprendre quelques techniques avanc\xe9es pour r\xe9duire la m\xe9moire des dimensions, des relations et des colonnes pertinentes, afin d'acc\xe9l\xe9rer leur utilisation."),(0,s.kt)("h3",{id:"sum-ou-sumx-"},"SUM ou SUMX ?"),(0,s.kt)("p",null,"Est-il pr\xe9f\xe9rable d'utiliser SUM ou SUMX?"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_12",src:n(11065).Z,width:"447",height:"279"})),(0,s.kt)("p",null,"Si vous naviguez sur internet vous trouverez des sites qui disent que SUMX est plus lent que SUM et pr\xe9f\xe9rable d'utiliser plus la fonction SUM()."),(0,s.kt)("p",null,"En effet il y'a des ann\xe9es , mais aujourd'hui SUMX et SUM font la m\xeame chose, donc si vous \xe9ecriverz un Sumx() vous parcourez la m\xeame table o\xf9 vous avez la colonne de Sum() .\nPar contre en Sumx() vous pouvez \xe9crire des expressions plus complexes qui demandera plus de m\xe9moire et plus de temps de r\xe9ponse, c'est logique qu'elle prenne plus de RAM et plus de temps pour balayer les colonnes \xe0 multiplier ou autres."),(0,s.kt)("h3",{id:"optimisation-des-dimensions-d\xe9g\xe9n\xe9r\xe9es"},"Optimisation des dimensions d\xe9g\xe9n\xe9r\xe9es"),(0,s.kt)("p",null,"Une autre optimisation que vous pouvez envisager est celle d'une dimension d\xe9g\xe9n\xe9r\xe9e, cette solution se fait habituellement dans l'entrep\xf4t de donn\xe9es ou sch\xe9ma en \xe9toile."),(0,s.kt)("p",null,"Une dimension d\xe9g\xe9n\xe9r\xe9e est une dimension que l\u2019on stocke dans la table de faits sous la forme d\u2019un unique attribut. Il s\u2019agit d\u2019un attribut qui peut servir d\u2019axe d\u2019analyse sans table de dimension. Parfois, il d\xe9finit \xe9galement le grain de la table de faits.",(0,s.kt)("img",{alt:"image-20220204162904953",src:n(4443).Z,width:"535",height:"459"})),(0,s.kt)("h3",{id:"dimension-bottlenecks"},"Dimension bottlenecks"),(0,s.kt)("p",null,"Prenant le sc\xe9nario d'un simple mod\xe8le qui contient une table de produit de 1 millions de lignes et une table de fait qui contient les ventes par produit \xe0 10 milliards de lignes. Alors dans ce cas vous allez avoir un probl\xe8me si vous voulez calculer une somme du montant des ventes par couleur de produit et le temps de r\xe9ponse sera lent \xe0 cause de 1 millions de lignes de la table produit. "),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_13",src:n(63490).Z,width:"878",height:"489"})),(0,s.kt)("p",null,"C'est pour cela qu'on propose de faire des tables de cat\xe9gories et sous-cat\xe9gories, pour qu'\xe0 la place de parcourir1 million s de lignes , la table fait va parcourir que 10 000 lignes uniques (image ci-dessous)."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Optimistation-DAX_14",src:n(64176).Z,width:"552",height:"425"})),(0,s.kt)("p",null,"Comme vous remarquez la relation et non-actif entre la table produit cat\xe9gorie et ventes par produit cat\xe9gorie, mais vous pouvez cr\xe9er du code DAX que si la requ\xeate interroge uniquement le regroupement par cat\xe9gorie , la requ\xeate DAX utilisera la relation non-actif \xe0 la place de la relation actif .\n",(0,s.kt)("em",{parentName:"p"},"La fonction qui sert pour cette requ\xeate est USERELATIONSHIP ()"),"."))}m.isMDXComponent=!0},53378:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_1-7716d5a475517f9d54b706d9d9ee15e9.png"},79335:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_10-e0b8df933aecc2f6e94e8174bb8665da.png"},81421:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_11-104ccfa2ad41fd000d47d535dc6a4880.png"},11065:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_12-f6002adb894aa415f3e0533101f64238.png"},4443:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_13-0eeff9acbfa65ab4d31b6c4c7dede43c.png"},63490:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_14-a3af412966364160faf646afdc9ab300.png"},64176:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_15-461fb6ec88feac09c023d3f3783fed89.png"},79151:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_2-64ef793a0041bf1275010f861fd4c296.png"},80300:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_3-e6ced8957fe4965e1a30fd175edb0049.png"},99863:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_4-ed250a13e59c3257e2ebaa6d91fd7461.png"},13959:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_5-cea17b420ab14a7d759a47c12760d1c6.png"},55800:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_6-603955e227e990bbfbe96ec962fb5b3f.png"},88869:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_7-ceac7121118bf8bf993963326cee8597.png"},69023:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_8-0091a581a1b1811793c15be2fef7bc19.png"},25030:function(e,t,n){t.Z=n.p+"assets/images/Optimistation-DAX_9-dd5c4c8a41b702fa3a181874f40e425b.png"}}]);